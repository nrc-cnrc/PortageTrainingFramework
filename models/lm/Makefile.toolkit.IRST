# vim:noet:ts=3:nowrap:filetype=make

$(info Using IRSTLM)

ifeq ($(shell which build-lm.sh 2> /dev/null),)
$(error You are missing a key software component build-lm.sh)
endif

ifeq ($(shell echo $IRSTLM),)
$(error You must set in your environment IRSTLM)
endif

# Allows to switch between a cluster distributed way of building the irstlm format.
ifdef USING_CLUSTER
BUILD_LM_PGM ?= build-lm-qsub.sh
else
BUILD_LM_PGM ?= build-lm.sh
endif


# Set the proper order of lm based on file name.
# Create the model's dependency.
$(foreach o, 1 2 3 4 5 6 7 8 9, \
	$(eval %$og-kn.lm.gz: ORDER=$o) \
	$(foreach c, ${CORPUS_NAME}, \
		$(eval $c-$og-kn.ilm.gz: $c.marked.gz)))


########################################
# Adds sentence start and end markers
.PHONY: mark
mark: ${CORPUS_NAME}.marked.gz

#.SECONDARY: ${CORPUS_NAME}.marked.gz
%.marked.gz: %${CORPUS_EXT}
	@_LOCAL=1 echo "Marking up $<"
	RP_PSUB_OPTS="-N $@" \
	set -o pipefail; zcat -f $< \
	| add-start-end.sh \
	| gzip -c \
	> $@

clean.content: clean.mark

.PHONY: clean.mark
clean.mark: SHELL=${GUARD_SHELL}
clean.mark:
	${RM} *.marked.gz



########################################
# iARPA
# Compressed irstlm format
.PHONY: irstlm
irstlm: $(addsuffix .ilm.gz, ${LM_NAME})

# Here we've added LM_DESC to strip it out from the marked corpus file name.
#.SECONDARY: $(addsuffix .ilm.gz, ${LM_NAME})
#%${LM_DESC}.ilm.gz: %.marked.gz
%.ilm.gz:
	@_LOCAL=1 echo "  Creating IRSTLM $@"
	_LOCAL=1 ${RM} $@
	RP_PSUB_OPTS="-${CPUS} -N $@" \
	IRSTLM=${IRSTLM} ${BUILD_LM_PGM} \
		-p \
		-t stat.$$$$ \
		-n ${ORDER} \
		-k ${PARALLELISM_LEVEL_LM} \
		-s kneser-ney \
		-i "gunzip -c $<" \
		-o $@ \
	&> log.$(basename $@)

clean.content: clean.irstlm

.PHONY: clean.irstlm
clean.irstlm: SHELL=${GUARD_SHELL}
clean.irstlm:
	${RM} *.ilm.gz
	${RM} -r stat*



########################################
# arpa text compressed format
%.lm.gz: %.ilm.gz
	@_LOCAL=1 echo "  Creating ARPA text format $@"
	RP_PSUB_OPTS="-${CPUS} -N $@" \
	set -o pipefail; \
	${TIME_MEM} \
	compile-lm \
		--text yes \
		$< \
		/dev/stdout \
	2> log.$(basename $@) \
	| egrep -v '^Saving in txt format to' \
	| lm_sort.pl \
	| gzip > $@



########################################
# BINARY FORMAT
# arpa bin compressed format
.PHONY: blmt
blmt: $(addsuffix .blmt, ${LM_NAME})

#.SECONDARY: $(addsuffix .blmt, ${LM_NAME})
%.blmt: %.ilm.gz
	@_LOCAL=1 echo "  Creating bin.ARPA format $@"
	RP_PSUB_OPTS="-${CPUS} -N $@" \
	${TIME_MEM} \
	compile-lm \
		$< \
		$@ \
	&> log.$@

clean.content: clean.blmt

.PHONY: clean.blmt
clean.blmt: SHELL=${GUARD_SHELL}
clean.blmt:
	${RM} *.blmt



########################################
# qARPA format
.PHONY: quantize
quantize: $(addsuffix .qlm.gz, ${LM_NAME})

#.SECONDARY: $(addsuffix .qlm.gz, ${LM_NAME})
%.qlm: %.lm.gz
	@_LOCAL=1 echo "  qARPA $< to $@"
	RP_PSUB_OPTS="-${CPUS} -N $@" \
	${TIME_MEM} \
	quantize-lm \
		$< \
		$@ \
	&> log.$@

clean.content: clean.quantize

.PHONY: clean.quantize
clean.quantize: SHELL=${GUARD_SHELL}
clean.quantize:
	${RM} *.qlm.gz



########################################
# Quantize binary
.PHONY: Qblmt
Qblmt: $(addsuffix .Qblmt, ${LM_NAME})

#.SECONDARY: $(addsuffix .Qblmt, ${LM_NAME})
%.Qblmt: %.qlm.gz
	@_LOCAL=1 echo "  bin.qARPA $< to $@"
	RP_PSUB_OPTS="-${CPUS} -N $@" \
	${TIME_MEM} \
	compile-lm \
		$< \
		$@ \
	&> log.$@

clean.content: clean.Qblmt

.PHONY: clean.Qblmt
clean.Qblmt: SHELL=${GUARD_SHELL}
clean.Qblmt:
	${RM} *.Qblmt



########################################
# Sort the arpa format
.PHONY: sort_arpa
sort_arpa: $(addsuffix .lm.sorted.gz, ${LM_NAME})

#.SECONDARY: $(addsuffix .lm.sorted.gz, ${LM_NAME})
%.lm.sorted.gz: %.lm.gz
	${TIME_MEM} \
	lm_sort_filter.sh -lm $< $@ >& log.$(basename $@)

clean.content: clean.sort_arpa

.PHONY: clean.sort_arpa
clean.sort_arpa: SHELL=${GUARD_SHELL}
clean.sort_arpa:
	${RM} *.lm.sorted.gz



########################################
# Pruning ARPA format => ARPA format
.PHONY: prune
prune: $(addsuffix .plm.gz, ${LM_NAME})

#.SECONDARY: $(addsuffix .plm.gz, ${LM_NAME})
%.plm.gz: %.lm.gz
	RP_PSUB_OPTS="-${CPUS} -N $@" \
	prune-lm --threshold=1e-6 $< /dev/stdout \
	| gzip \
	> $@



################################################################################
# HELPERS
########################################
# All valid/possible LMs
.PHONY: all_lm
all_lm: arpa
all_lm: blmt
all_lm: quantize
all_lm: Qblmt
all_lm: binlm



########################################
# Check if the environment is set
.PHONY: test
test: SHELL=${GUARD_SHELL}
test:
	env | grep IRSTLM



########################################
# For debugging purpose
.PHONY: check_setup
check_setup: SHELL=${GUARD_SHELL}
check_setup:
	test -n $$IRSTLM
	which build-lm.sh

