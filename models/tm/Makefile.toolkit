# vim:noet:ts=3:nowrap
# $Id$

# @file Makefile.toolkit
# @brief
#
# @author Samuel Larkin
#
# Technologies langagieres interactives / Interactive Language Technologiesm
# Inst. de technologie de l'information / Institute for Information Technology
# Conseil national de recherches Canada / National Research Council Canada
# Copyright 2010, Sa Majeste la Reine du Chef du Canada /
# Copyright 2010, Her Majesty in Right of Canada


-include ../../Makefile.params

SHELL = ${FRAMEWORK_SHELL}

export LANG   = en_CA.utf8
export LC_ALL = en_CA.utf8


# Default language corpora extension.
LANGXZ ?= .gz

# Lets rename the language identifiers for the toolkit.
lang1 = ${SRC_LANG}
lang2 = ${TGT_LANG}

# Language file extension.
L1X ?= _${SRC_LANG}${LANGXZ}
L2X ?= _${TGT_LANG}${LANGXZ}

# IBM / HMM models extension.
L1_GIVEN_L2  ?= ${lang1}_given_${lang2}
L2_GIVEN_L1  ?= ${lang2}_given_${lang1}
L1_GIVEN_L2X ?= ${L1_GIVEN_L2}.gz
L2_GIVEN_L1X ?= ${L2_GIVEN_L1}.gz

# conditional phrase table extension.
L1_2_L2  ?= ${lang1}2${lang2}
L2_2_L1  ?= ${lang2}2${lang1}
L1_2_L2X ?= ${L1_2_L2}.gz
L2_2_L1X ?= ${L2_2_L1}.gz

# Joint phrase table extension.
JOINT  ?= ${lang1}-${lang2}
JOINTX ?= ${JOINT}.gz
RJOINT  ?= ${lang2}-${lang1}
RJOINTX ?= ${RJOINT}.gz

# Lets define a parallelism level if the user forgets about it.
PARALLELISM_LEVEL_TM ?= $(shell grep processor /proc/cpuinfo | \wc -l)

# Maximum phrase length.
M ?= 8

# What program to use to train models.
CAT ?= cat.sh

# We don't need to sort if we are using -reduce-mem and sorted jpts which is
# the case in the framework.
JOINT2COND_PHRASE_TABLE_OPTION ?= -reduce-mem -no-sort


# Track memory usage.
TIME_MEM ?= time-mem


########################################
# IBM1 MODELS.
IBM1_MODEL_PFX ?= ibm1
IBM1_MODEL_CPUS ?= 1
IBM1_MODEL_PARALLELISM_LEVEL ?= ${PARALLELISM_LEVEL_TM}
IBM1_MODEL_WORKERS ?= ${IBM1_MODEL_PARALLELISM_LEVEL}
IBM1_MODEL_EXTRAS ?=

########################################
# IBM2 MODELS.
IBM2_MODEL_PFX ?= ibm2
IBM2_MODEL_CPUS ?= 1
IBM2_MODEL_PARALLELISM_LEVEL ?= ${PARALLELISM_LEVEL_TM}
IBM2_MODEL_WORKERS ?= ${IBM2_MODEL_PARALLELISM_LEVEL}
IBM2_MODEL_EXTRAS ?=

########################################
# HMM1 MODELS.
HMM1_MODEL_PFX ?= hmm1
HMM1_MODEL_CPUS ?= 1
HMM1_MODEL_PARALLELISM_LEVEL ?= ${PARALLELISM_LEVEL_TM}
HMM1_MODEL_WORKERS ?= ${HMM1_MODEL_PARALLELISM_LEVEL}
HMM1_MODEL_EXTRAS ?=

########################################
# HMM2 MODELS.
HMM2_MODEL_PFX ?= hmm2
HMM2_MODEL_CPUS ?= 1
HMM2_MODEL_PARALLELISM_LEVEL ?= ${PARALLELISM_LEVEL_TM}
HMM2_MODEL_WORKERS ?= ${HMM2_MODEL_PARALLELISM_LEVEL}
HMM2_MODEL_EXTRAS ?=

########################################
# HMM3 MODELS.
HMM3_MODEL_PFX ?= hmm3
HMM3_MODEL_CPUS ?= 1
HMM3_MODEL_PARALLELISM_LEVEL ?= ${PARALLELISM_LEVEL_TM}
HMM3_MODEL_WORKERS ?= ${HMM3_MODEL_PARALLELISM_LEVEL}
HMM3_MODEL_EXTRAS ?=
# Autodetect whether -newhmm is supported (i.e., it's not in PORTAGEshared).
NEW_HMM := $(addprefix(-, $(strip $(shell train_ibm -h 2>&1 | grep -om1 newhmm)))

########################################
# JPT MODELS.
JPT_MODEL_PFX ?= jpt
JPT_CPUS ?= 1
JPT_PARALLELISM_LEVEL ?= ${PARALLELISM_LEVEL_TM}
JPT_WORKERS ?= ${JPT_PARALLELISM_LEVEL}

########################################
# CPT MODELS.
CPT_MODEL_PFX ?= cpt
CPT_CPUS ?= 4
CPT_SMOOTHERS ?= -s RFSmoother  -s ZNSmoother

########################################
# TPPT MODELS.
TPPT_CPUS ?= 4

########################################
# FUNCTIONS.
# Joins two parallel lists of words.
interleave = $(strip $(subst \, , $(join ${1}, $(addprefix \, ${2}))))
# Make sure we interleave only the corpora and that we exclude the models.
# filter_interleave list1_extension list2_extension filt-out-model all-files
filter_interleave = $(call interleave, $(filter ${1}, $(filter-out ${3}, ${4})), $(filter ${2}, $(filter-out ${3}, ${4})))



################################################################################
# ARGUMENTS VALIDATION.
ifndef lang1
$(error "You must define lang1")
endif

ifndef lang2
$(error "You must define lang2")
endif

ifndef PARALLELISM_LEVEL_TM
$(error "You must define PARALLELISM_LEVEL_TM")
endif



########################################
# NOTES:
# - We should have some rules to clean each type of models!?
# - We might want to collapse the 3 hmm targets/rules into 1.
# - lang1 & lang2 are side effects of WMT-ACL10 and we might want to rename
#   them to L1 & L2.
# - We also need to remove the hardcoded SHELL variable in this script to use
#   the FRAMEWORK_SHELL of the portage.simple.framework.



########################################
# IBM1 MODELS
# requires: source and target corpora.
${IBM1_MODEL_PFX}%${L1_GIVEN_L2X}: IBM1_DIR=-r
${IBM1_MODEL_PFX}.%.gz:
	RP_PSUB_OPTS="-${IBM1_MODEL_CPUS} -N $@ ${PSUB_OPTS}" \
	${CAT} -n ${IBM1_MODEL_PARALLELISM_LEVEL} -pn ${IBM1_MODEL_WORKERS} \
		-v ${IBM1_DIR} \
		-n1 5 -n2 0 \
		-bin \
		${IBM1_MODEL_EXTRAS} \
		$@ \
		$(call interleave, $(filter %${L1X}, $+), $(filter %${L2X}, $+)) \
		>& log.$(basename $@)



########################################
# IBM2 MODELS
${IBM2_MODEL_PFX}%${L1_GIVEN_L2X}: IBM2_DIR=-r
${IBM2_MODEL_PFX}.%.gz:  ${IBM1_MODEL_PFX}.%.gz
	RP_PSUB_OPTS="-${IBM2_MODEL_CPUS} -N $@ ${PSUB_OPTS}" \
	${CAT} -n ${IBM2_MODEL_PARALLELISM_LEVEL} -pn ${IBM2_MODEL_WORKERS} \
		-v ${IBM2_DIR} \
		-n1 0 -n2 5 \
		-slen 20 -tlen 20 -bksize 20 \
		-bin \
		-i $(filter ${IBM1_MODEL_PFX}.%.gz, $^) \
		${IBM2_MODEL_EXTRAS} \
		$@ \
		$(call filter_interleave, %${L1X}, %${L2X}, ${IBM1_MODEL_PFX}.%.gz, $+) \
		>& log.$(basename $@)



########################################
# HMM1 MODELS
${HMM1_MODEL_PFX}%${L1_GIVEN_L2X}: HMM1_DIR=-r
${HMM1_MODEL_PFX}.%.gz:  ${IBM1_MODEL_PFX}.%.gz
	RP_PSUB_OPTS="-${HMM1_MODEL_CPUS} -N $@ ${PSUB_OPTS}" \
	${CAT} -n ${HMM1_MODEL_PARALLELISM_LEVEL} -pn ${HMM1_MODEL_WORKERS} \
		-v ${HMM1_DIR} \
		-n1 0 -n2 5 \
		-mimic he-lex \
		-bin \
		-i $(filter ${IBM1_MODEL_PFX}.%.gz, $^) \
		${HMM1_MODEL_EXTRAS} \
		$@ \
		$(call filter_interleave, %${L1X}, %${L2X}, ${IBM1_MODEL_PFX}.%.gz, $+) \
		>& log.$(basename $@)



########################################
# HMM2 MODELS
${HMM2_MODEL_PFX}%${L1_GIVEN_L2X}: HMM2_DIR=-r
${HMM2_MODEL_PFX}.%.gz:  ${IBM1_MODEL_PFX}.%.gz
	RP_PSUB_OPTS="-${HMM2_MODEL_CPUS} -N $@ ${PSUB_OPTS}" \
	${CAT} -n ${HMM2_MODEL_PARALLELISM_LEVEL} -pn ${HMM2_MODEL_WORKERS} \
		-v ${HMM2_DIR} \
		-n1 0 -n2 5 \
		-mimic liang \
		-bin \
		-i $(filter ${IBM1_MODEL_PFX}.%.gz, $^) \
		${HMM2_MODEL_EXTRAS} \
		$@ \
		$(call filter_interleave, %${L1X}, %${L2X}, ${IBM1_MODEL_PFX}.%.gz, $+) \
		>& log.$(basename $@)



########################################
# HMM3 MODELS
${HMM3_MODEL_PFX}%${L1_GIVEN_L2X}: HMM3_DIR=-r
${HMM3_MODEL_PFX}.%.gz:  ${IBM1_MODEL_PFX}.%.gz
	RP_PSUB_OPTS="-${HMM3_MODEL_CPUS} -N $@ ${PSUB_OPTS}" \
	${CAT} -n ${HMM3_MODEL_PARALLELISM_LEVEL} -pn ${HMM3_MODEL_WORKERS} \
		-v ${HMM3_DIR} \
		-n1 0 -n2 5 \
		-hmm ${NEW_HMM} -end-dist -anchor -max-jump 20 -alpha 0.0 -lambda 1.0 -p0 0.6 -up0 0.5 \
		-bin \
		-i $(filter ${IBM1_MODEL_PFX}.%.gz, $^) \
		${HMM3_MODEL_EXTRAS} \
		$@ \
		$(call filter_interleave, %${L1X}, %${L2X}, ${IBM1_MODEL_PFX}.%.gz, $+) \
		>& log.$(basename $@)



########################################
# JPT MODELS
${JPT_MODEL_PFX}.${IBM1_MODEL_PFX}%: JPT_MODEL_TYPE=-ibm 1
${JPT_MODEL_PFX}.${IBM2_MODEL_PFX}%: JPT_MODEL_TYPE=-ibm 2
${JPT_MODEL_PFX}.hmm%: JPT_MODEL_TYPE=-hmm
${JPT_MODEL_PFX}.%.${JOINTX}:
	RP_PSUB_OPTS="-${JPT_CPUS} -N $@ ${PSUB_OPTS}" \
	gen-jpt-parallel.sh \
		-n ${JPT_PARALLELISM_LEVEL} \
		-nw ${JPT_WORKERS} \
		-w 1 \
		-o $@ \
		GPT \
		-v -m ${M} ${JPT_MODEL_TYPE} \
		-1 ${lang1} -2 ${lang2} \
		${JPT_EXTRAS} \
		$(filter %${L2_GIVEN_L1X}, $+) $(filter %${L1_GIVEN_L2X}, $+) \
		$(call filter_interleave, %${L1X}, %${L2X}, %${L1_GIVEN_L2X} %${L2_GIVEN_L1X}, $+) \
		>& log.$(basename $@)



########################################
# CPT MODELS
${CPT_MODEL_PFX}.${IBM1_MODEL_PFX}%: WORD_MODEL_TYPE=-ibm 1
${CPT_MODEL_PFX}.${IBM2_MODEL_PFX}%: WORD_MODEL_TYPE=-ibm 2
${CPT_MODEL_PFX}.hmm%: WORD_MODEL_TYPE=-hmm
${CPT_MODEL_PFX}.%: CPT_PRUNE1=-prune1 100

${CPT_MODEL_PFX}%${L1_2_L2X}:
	RP_PSUB_OPTS="-${CPT_CPUS} -N $@ ${PSUB_OPTS}" \
	${TIME_MEM} \
	joint2cond_phrase_tables \
		${CPT_PRUNE1} \
		-v -i -z \
		${WORD_MODEL_TYPE} \
		-1 ${lang1} -2 ${lang2} \
		${CPT_SMOOTHERS} \
		-multipr fwd \
		-o $(subst .${L1_2_L2X},,$@) \
		-ibm_l2_given_l1  $(filter %${L2_GIVEN_L1X}, $+) \
		-ibm_l1_given_l2  $(filter %${L1_GIVEN_L2X}, $+) \
		${JOINT2COND_PHRASE_TABLE_OPTION} \
		$(filter %${JOINTX}, $+) \
		>& log.$(basename $@)

# Special case to make valid prune1 reversed conditional phrase tables.
# Requires:
# - forward & backward phrase alignment models;
# - reversed joint frequency files.
${CPT_MODEL_PFX}%${L2_2_L1X}:
	RP_PSUB_OPTS="-${CPT_CPUS} -N $@ ${PSUB_OPTS}" \
	${TIME_MEM} \
	joint2cond_phrase_tables \
		${CPT_PRUNE1} \
		-v -i -z \
		${WORD_MODEL_TYPE} \
		-1 ${lang2} -2 ${lang1} \
		${CPT_SMOOTHERS} \
		-multipr fwd \
		-o $(subst .${L2_2_L1X},,$@) \
		-ibm_l2_given_l1  $(filter %${L1_GIVEN_L2X}, $+) \
		-ibm_l1_given_l2  $(filter %${L2_GIVEN_L1X}, $+) \
		${JOINT2COND_PHRASE_TABLE_OPTION} \
		$(filter %.${RJOINTX}, $+) \
		>& log.$(basename $@)



########################################
# Create tightly packed conditional phrase table.
%.tppt: SHELL=${FRAMEWORK_SHELL}
%.tppt: %.gz
	RP_PSUB_OPTS="-${TPPT_CPUS} -N $@" \
	${TIME_MEM} \
	textpt2tppt.sh -v $< \
	2> log.$@


########################################
# Transform models for PortageLive
# Note: portageLive dependencies are defined in Makefile (or Makefile.zn-adapt)
PORTAGE_LIVE_DEST_DIR ?= ../portageLive/models/tm
.PHONY: portageLive
portageLive: SHELL=${GUARD_SHELL}
portageLive:
	mkdir -p ${PORTAGE_LIVE_DEST_DIR}
	${RM} -r ${PORTAGE_LIVE_DEST_DIR}/*
	cd ${PORTAGE_LIVE_DEST_DIR} && ln -fs $(addprefix ../../../tm/, $+) .


################################################################################
# HELPERS

########################################
# INVERT ANY JOINT PHRASE TABLE
# WARNING: Using tmtext_sort.sh produces a valid jpt for joint2cond but
# produces an INVALID jpt for merge_counts.  Prefer the version using LC_ALL=C
# sort rather than tmtext_sort.
%.${RJOINTX}: %.${JOINTX}
	@_LOCAL=1; echo "Generating $@" >&2
	RP_PSUB_OPTS="-1 -N $@" \
	zcat $< \
	| reverse_joint_phr_tab.py \
	| TMPDIR=. LC_ALL=C sort \
	| gzip \
	> $@

