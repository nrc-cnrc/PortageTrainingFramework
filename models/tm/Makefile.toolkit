# vim:noet:ts=3:nowrap
# $Id$

# @file Makefile.toolkit
# @brief
#
# @author Samuel Larkin
#
# Technologies langagieres interactives / Interactive Language Technologies
# Inst. de technologie de l'information / Institute for Information Technology
# Conseil national de recherches Canada / National Research Council Canada
# Copyright 2010, Sa Majeste la Reine du Chef du Canada /
# Copyright 2010, Her Majesty in Right of Canada


-include ../../Makefile.params
include ../../gmsl/gmsl   # functions: uc

UTF8 = $(if $(findstring Darwin, ${OSTYPE}),UTF-8,utf8)
export LANG   = en_CA.${UTF8}
export LC_ALL = en_CA.${UTF8}


# Default language corpora extension.
LANGXZ ?= .gz

# Lets rename the language identifiers for the toolkit.
lang1 = ${SRC_LANG}
lang2 = ${TGT_LANG}

# Language file extension.
L1X ?= _${SRC_LANG}${LANGXZ}
L2X ?= _${TGT_LANG}${LANGXZ}

# IBM / HMM models extension.
L1_GIVEN_L2  ?= ${lang1}_given_${lang2}
L2_GIVEN_L1  ?= ${lang2}_given_${lang1}
L1_GIVEN_L2X ?= ${L1_GIVEN_L2}.gz
L2_GIVEN_L1X ?= ${L2_GIVEN_L1}.gz

# conditional phrase table extension.
L1_2_L2  ?= ${lang1}2${lang2}
L2_2_L1  ?= ${lang2}2${lang1}
L1_2_L2X ?= ${L1_2_L2}.gz
L2_2_L1X ?= ${L2_2_L1}.gz

# Joint phrase table extension.
JOINT  ?= ${lang1}-${lang2}
JOINTX ?= ${JOINT}.gz
RJOINT  ?= ${lang2}-${lang1}
RJOINTX ?= ${RJOINT}.gz

# This is already done in ../../Makefile.params, and we should not use
# $(shell ...) in cluster mode, so we don't want to run this all the time.
# Lets define a parallelism level if the user forgets about it.
#NUM_LOCAL_CPUS := $(shell grep processor /proc/cpuinfo | \wc -l)
#PARALLELISM_LEVEL_TM ?= ${NUM_LOCAL_CPUS}

# Maximum phrase length.
M ?= 8

# What program to use to train models.
CAT ?= cat.sh

# We don't need to sort if we are using -reduce-mem and sorted jpts which is
# the case in the framework.
JOINT2COND_PHRASE_TABLE_OPTION ?= -reduce-mem -no-sort


# Track memory usage.
TIME_MEM ?= time-mem


########################################
# IBM1 MODELS.
IBM1_MODEL_PFX ?= ibm1
IBM1_MODEL_CPUS ?= 1
IBM1_MODEL_PARALLELISM_LEVEL ?= ${PARALLELISM_LEVEL_TM}
IBM1_MODEL_WORKERS ?= ${IBM1_MODEL_PARALLELISM_LEVEL}
IBM1_MODEL_EXTRAS ?=

########################################
# IBM2 MODELS.
IBM2_MODEL_PFX ?= ibm2
IBM2_MODEL_CPUS ?= 1
IBM2_MODEL_PARALLELISM_LEVEL ?= ${PARALLELISM_LEVEL_TM}
IBM2_MODEL_WORKERS ?= ${IBM2_MODEL_PARALLELISM_LEVEL}
IBM2_MODEL_EXTRAS ?=

########################################
# HMM1 MODELS.
HMM1_MODEL_PFX ?= hmm1
HMM1_MODEL_CPUS ?= 1
HMM1_MODEL_PARALLELISM_LEVEL ?= ${PARALLELISM_LEVEL_TM}
HMM1_MODEL_WORKERS ?= ${HMM1_MODEL_PARALLELISM_LEVEL}
HMM1_MODEL_EXTRAS ?=

########################################
# HMM2 MODELS.
HMM2_MODEL_PFX ?= hmm2
HMM2_MODEL_CPUS ?= 1
HMM2_MODEL_PARALLELISM_LEVEL ?= ${PARALLELISM_LEVEL_TM}
HMM2_MODEL_WORKERS ?= ${HMM2_MODEL_PARALLELISM_LEVEL}
HMM2_MODEL_EXTRAS ?=

########################################
# HMM3 MODELS.
HMM3_MODEL_PFX ?= hmm3
HMM3_MODEL_CPUS ?= 1
HMM3_MODEL_PARALLELISM_LEVEL ?= ${PARALLELISM_LEVEL_TM}
HMM3_MODEL_WORKERS ?= ${HMM3_MODEL_PARALLELISM_LEVEL}
HMM3_MODEL_EXTRAS ?=
# Autodetect whether -newhmm is supported (i.e., it's not in PORTAGEshared).
NEW_HMM := $(addprefix(-, $(strip $(shell train_ibm -h 2>&1 | grep -om1 newhmm)))

########################################
# GIZA MODELS
GIZA_MODEL_PFX ?= giza

########################################
# List of all possible word alignment models in the framework.
POSSIBLE_WORD_ALIGNMENT_MODELS := ${IBM1_MODEL_PFX} ${IBM2_MODEL_PFX} ${HMM1_MODEL_PFX} ${HMM2_MODEL_PFX} ${HMM3_MODEL_PFX} 

########################################
# JPT MODELS.
JPT_MODEL_PFX ?= jpt
JPT_CPUS ?= 1
JPT_PARALLELISM_LEVEL ?= ${PARALLELISM_LEVEL_TM}
JPT_WORKERS ?= ${JPT_PARALLELISM_LEVEL}

########################################
# SIG MODELS.
SIG_CPUS ?= 1
SIG_OPTS ?=
SIG_THRESHOLD ?= a+e
SIG_MODEL_PFX ?= sig.${SIG_THRESHOLD}
SIG_MODEL_PARALLELISM_LEVEL ?= ${PARALLELISM_LEVEL_TM}
SIG_MODEL_WORKERS ?= ${SIG_MODEL_PARALLELISM_LEVEL}
# Create variables to hold significance model prefix.
$(foreach m, $(call uc, ${POSSIBLE_WORD_ALIGNMENT_MODELS} ${GIZA_MODEL_PFX}), \
   $(eval \
	   SIG_${m}_MODEL_PFX ?= ${SIG_MODEL_PFX}.${${m}_MODEL_PFX}) \
)

########################################
# CPT MODELS.
CPT_MODEL_PFX ?= cpt
CPT_CPUS ?= 4
#CPT_SMOOTHERS ?= -s RFSmoother  -s ZNSmoother
#SMOOTHERS_DESCRIPTION ?= -rf-zn
CPT_SMOOTHERS ?= -s "KNSmoother 3"  -s ZNSmoother
SMOOTHERS_DESCRIPTION ?= -kn3-zn

########################################
# TPPT MODELS.
TPPT_CPUS ?= ${CPT_CPUS}

########################################
# Switch cpts dependencies from jpt to sig.
ifdef USE_SIGPRUNING
CPT_DEP_TAG := SIG
else
CPT_DEP_TAG := JPT
endif

########################################
# FUNCTIONS.
# Joins two parallel lists of words.
interleave  = $(strip $(subst , , $(join $1, $(addprefix , $2))))
interleave3 = $(strip $(subst , , $(join $1, $(addprefix , $(join $2, $(addprefix , $3))))))
interleave4 = $(strip $(subst , , $(join $1, $(addprefix , $(join $2, $(addprefix , $(join $3, $(addprefix , $4))))))))
# Make sure we interleave only the corpora and that we exclude the models.
# filter_interleave list1_extension list2_extension filt-out-model all-files
filter_interleave = $(call interleave, $(filter $1, $(filter-out $3, $4)), $(filter $2, $(filter-out $3, $4)))



################################################################################
# ARGUMENTS VALIDATION.
ifndef lang1
$(error You must define lang1)
endif

ifndef lang2
$(error You must define lang2)
endif

ifndef PARALLELISM_LEVEL_TM
$(error You must define PARALLELISM_LEVEL_TM)
endif



########################################
# NOTES:
# - We should have some rules to clean each type of models!?
# - We might want to collapse the 3 hmm targets/rules into 1.
# - lang1 & lang2 are side effects of WMT-ACL10 and we might want to rename
#   them to L1 & L2.
# - We also need to remove the hardcoded SHELL variable in this script to use
#   the FRAMEWORK_SHELL of the portage.simple.framework.



########################################
# IBM1 MODELS
# requires: source and target corpora.
${IBM1_MODEL_PFX}%${L1_GIVEN_L2X}: IBM1_DIR=-r
${IBM1_MODEL_PFX}.%.gz:  SHELL=${FRAMEWORK_SHELL}
${IBM1_MODEL_PFX}.%.gz:
	RP_PSUB_OPTS="-${IBM1_MODEL_CPUS} -N $@ ${PSUB_OPTS}" \
	${CAT} -n $(call IBM1_MODEL_PARALLELISM_LEVEL, $+) -pn $(call IBM1_MODEL_WORKERS, $+) \
		-v ${IBM1_DIR} \
		-n1 5 -n2 0 \
		-bin \
		${IBM1_MODEL_EXTRAS} \
		$@ \
		$(call interleave, $(filter %${L1X}, $+), $(filter %${L2X}, $+)) \
		&> log.${@:.gz=}



########################################
# IBM2 MODELS
${IBM2_MODEL_PFX}%${L1_GIVEN_L2X}: IBM2_DIR=-r
${IBM2_MODEL_PFX}.%.gz:  SHELL=${FRAMEWORK_SHELL}
${IBM2_MODEL_PFX}.%.gz:  ${IBM1_MODEL_PFX}.%.gz
	RP_PSUB_OPTS="-${IBM2_MODEL_CPUS} -N $@ ${PSUB_OPTS}" \
	${CAT} -n ${IBM2_MODEL_PARALLELISM_LEVEL} -pn ${IBM2_MODEL_WORKERS} \
		-v ${IBM2_DIR} \
		-n1 0 -n2 5 \
		-slen 20 -tlen 20 -bksize 20 \
		-bin \
		-i $(filter ${IBM1_MODEL_PFX}.%.gz, $^) \
		${IBM2_MODEL_EXTRAS} \
		$@ \
		$(call filter_interleave, %${L1X}, %${L2X}, ${IBM1_MODEL_PFX}.%.gz, $+) \
		&> log.${@:.gz=}



########################################
# HMM1 MODELS
${HMM1_MODEL_PFX}%${L1_GIVEN_L2X}: HMM1_DIR=-r
${HMM1_MODEL_PFX}.%.gz:  SHELL=${FRAMEWORK_SHELL}
${HMM1_MODEL_PFX}.%.gz:  ${IBM1_MODEL_PFX}.%.gz
	RP_PSUB_OPTS="-${HMM1_MODEL_CPUS} -N $@ ${PSUB_OPTS}" \
	${CAT} -n ${HMM1_MODEL_PARALLELISM_LEVEL} -pn ${HMM1_MODEL_WORKERS} \
		-v ${HMM1_DIR} \
		-n1 0 -n2 5 \
		-mimic he-lex \
		-bin \
		-i $(filter ${IBM1_MODEL_PFX}.%.gz, $^) \
		${HMM1_MODEL_EXTRAS} \
		$@ \
		$(call filter_interleave, %${L1X}, %${L2X}, ${IBM1_MODEL_PFX}.%.gz, $+) \
		&> log.${@:.gz=}



########################################
# HMM2 MODELS
${HMM2_MODEL_PFX}%${L1_GIVEN_L2X}: HMM2_DIR=-r
${HMM2_MODEL_PFX}.%.gz:  SHELL=${FRAMEWORK_SHELL}
${HMM2_MODEL_PFX}.%.gz:  ${IBM1_MODEL_PFX}.%.gz
	RP_PSUB_OPTS="-${HMM2_MODEL_CPUS} -N $@ ${PSUB_OPTS}" \
	${CAT} -n ${HMM2_MODEL_PARALLELISM_LEVEL} -pn ${HMM2_MODEL_WORKERS} \
		-v ${HMM2_DIR} \
		-n1 0 -n2 5 \
		-mimic liang \
		-bin \
		-i $(filter ${IBM1_MODEL_PFX}.%.gz, $^) \
		${HMM2_MODEL_EXTRAS} \
		$@ \
		$(call filter_interleave, %${L1X}, %${L2X}, ${IBM1_MODEL_PFX}.%.gz, $+) \
		&> log.${@:.gz=}



########################################
# HMM3 MODELS
#Note: We use "-end-dist" instead of "-start-dist -final-dist -anchor" because
#      PORTAGEshared lacks "-start-dist"
${HMM3_MODEL_PFX}%${L1_GIVEN_L2X}: HMM3_DIR=-r
${HMM3_MODEL_PFX}.%.gz:  SHELL=${FRAMEWORK_SHELL}
${HMM3_MODEL_PFX}.%.gz:  ${IBM1_MODEL_PFX}.%.gz
	RP_PSUB_OPTS="-${HMM3_MODEL_CPUS} -N $@ ${PSUB_OPTS}" \
	${CAT} -n ${HMM3_MODEL_PARALLELISM_LEVEL} -pn ${HMM3_MODEL_WORKERS} \
		-v ${HMM3_DIR} \
		-n1 0 -n2 5 \
		-hmm ${NEW_HMM} -end-dist -anchor -max-jump 20 -alpha 0.0 -lambda 1.0 -p0 0.6 -up0 0.5 \
		-bin \
		-i $(filter ${IBM1_MODEL_PFX}.%.gz, $^) \
		${HMM3_MODEL_EXTRAS} \
		$@ \
		$(call filter_interleave, %${L1X}, %${L2X}, ${IBM1_MODEL_PFX}.%.gz, $+) \
		&> log.${@:.gz=}



########################################
# Word Alignment Models.
ALIGN_MODEL_TYPE := -hmm
%.${IBM1_MODEL_PFX}.${L1_2_L2}.align.gz:  override ALIGN_MODEL_TYPE=-ibm 1
%.${IBM2_MODEL_PFX}.${L1_2_L2}.align.gz:  override ALIGN_MODEL_TYPE=-ibm 2

.PHONY: giza
giza:  $(addsuffix .${GIZA_MODEL_PFX}.${L1_2_L2}.align.gz, ${TRAIN_TM})
$(addsuffix .${GIZA_MODEL_PFX}.${L1_2_L2}.align.gz, ${TRAIN_TM}):  %.${GIZA_MODEL_PFX}.${L1_2_L2}.align.gz:  %/${SRC_LANG}.lc %/${TGT_LANG}.lc  %/${L1_2_L2}.${GIZA_MODEL_PFX}.alignment.gz %/${L2_2_L1}.${GIZA_MODEL_PFX}.alignment.gz

%.${GIZA_MODEL_PFX}.${L1_2_L2}.align.gz:
	RP_PSUB_OPTS="-N $@ ${PSUB_OPTS}" \
	time-mem \
	align-words \
		-o sri \
		-ibm 0 -giza2 \
		$(call interleave4, $(filter %${SRC_LANG}.lc,$+), $(filter %${TGT_LANG}.lc,$+), $(filter %${L1_2_L2}.${GIZA_MODEL_PFX}.alignment.gz,$+), $(filter %${L2_2_L1}.${GIZA_MODEL_PFX}.alignment.gz,$+)) \
		2> log.${@:.gz=} \
	| gzip > $@

%.${L1_2_L2}.align.gz:  SHELL=${FRAMEWORK_SHELL}
%.${L1_2_L2}.align.gz:
	RP_PSUB_OPTS="-N $@ ${PSUB_OPTS}" \
	set -o pipefail; \
	time-mem \
	align-words \
		-o sri \
		${ALIGN_MODEL_TYPE} \
		$(filter %${L2_GIVEN_L1X}, $+)  $(filter %${L1_GIVEN_L2X}, $+) \
		$(call filter_interleave, %${L1X}, %${L2X}, %${L2_GIVEN_L1X} %${L1_GIVEN_L2X}, $+) \
		2> log.${@:.gz=} \
	| gzip > $@


%.${L2_2_L1}.align.gz:  SHELL=${GUARD_SHELL}
%.${L2_2_L1}.align.gz:  %.${L1_2_L2}.align.gz
	set -o pipefail; \
	zcat $< \
	| perl -ple 's/(\d+)-(\d+)/$$2-$$1/g' \
	| gzip \
	2> log.${@:.gz=} \
	> $@



########################################
# JPT MODELS
# WARNING: The following two targets must precede the target to generate jpts.
# WARNING: % is purposefully not surrounded by dots for zn-adapt.
${JPT_MODEL_PFX}.merged%${JOINTX}: SHELL=${FRAMEWORK_SHELL}
${JPT_MODEL_PFX}.merged%${JOINTX}:
	merge_counts $@ $(filter %.${JOINTX}, $+) &> log.${@:.gz=}

${JPT_MODEL_PFX}.merged%${RJOINTX}: SHELL=${FRAMEWORK_SHELL}
${JPT_MODEL_PFX}.merged%${RJOINTX}:
	merge_counts $@ $(filter %.${RJOINTX}, $+) &> log.${@:.gz=}



${JPT_MODEL_PFX}.%.${JOINTX}:  SHELL=${FRAMEWORK_SHELL}
${JPT_MODEL_PFX}.${GIZA_MODEL_PFX}%: JPT_MODEL_TYPE = -ibm 1
${JPT_MODEL_PFX}.%.${JOINTX}:
	RP_PSUB_OPTS="-${JPT_CPUS} -N $@ ${PSUB_OPTS}" \
	gen-jpt-parallel.sh \
		-n ${JPT_PARALLELISM_LEVEL} \
		-nw ${JPT_WORKERS} \
		-w 1 \
		-o $@ \
		${GEN_JPT_PARALLEL_OPTIONS} \
		GPT \
		-v -m ${M} ${JPT_MODEL_TYPE} \
		-1 ${lang1} -2 ${lang2} \
		-ext \
		${JPT_EXTRAS} \
		$(filter %${L2_GIVEN_L1X}, $+) $(filter %${L1_GIVEN_L2X}, $+) \
		$(call interleave3, $(filter %${L1X},$+), $(filter %${L2X},$+), $(filter %.${L1_2_L2}.align.gz,$+)) \
		&> log.${@:.gz=}



########################################
# SIGNIFICANCE PRUNING
${SIG_MODEL_PFX}.%.${JOINTX}: SHELL=${FRAMEWORK_SHELL}
${SIG_MODEL_PFX}.%.${JOINTX}:
	RP_PSUB_OPTS="-${SIG_CPUS} -N $@ ${PSUB_OPTS}" \
	${TIME_MEM} \
	sigprune.sh \
		-n $(call SIG_MODEL_PARALLELISM_LEVEL, $+) \
		-np $(call SIG_MODEL_WORKERS, $+) \
		-w 50000 \
		-threshold ${SIG_THRESHOLD} \
		${SIG_OPTS} \
		$(filter %${JOINTX}, $+) \
		$(filter %${L1X}, $+) \
		$(filter %${L2X}, $+) \
		$@ \
		&> >(bzip2 > log.${@:.gz=}.bz2)


# According to Howard: generating a sig for L1 to L2 and then using
# reverse_joint_phr_tab.py to produce a sig for L2 to L1 is valide.
${SIG_MODEL_PFX}.%.${RJOINTX}: SHELL=${FRAMEWORK_SHELL}
${SIG_MODEL_PFX}.%.${RJOINTX}:
	RP_PSUB_OPTS="-${SIG_CPUS} -N $@ ${PSUB_OPTS}" \
	${TIME_MEM} \
	sigprune.sh \
		-n $(call SIG_MODEL_PARALLELISM_LEVEL, $+) \
		-np $(call SIG_MODEL_WORKERS, $+) \
		-w 50000 \
		-threshold ${SIG_THRESHOLD} \
		${SIG_OPTS} \
		$(filter %${RJOINTX}, $+) \
		$(filter %${L2X}, $+) \
		$(filter %${L1X}, $+) \
		$@ \
		&> >(bzip2 > log.${@:.gz=}.bz2)



########################################
# CPT MODELS
${CPT_MODEL_PFX}.${IBM1_MODEL_PFX}%: WORD_MODEL_TYPE=-ibm 1
${CPT_MODEL_PFX}.${IBM2_MODEL_PFX}%: WORD_MODEL_TYPE=-ibm 2
${CPT_MODEL_PFX}.hmm%: WORD_MODEL_TYPE=-hmm
${CPT_MODEL_PFX}.${GIZA_MODEL_PFX}%: WORD_MODEL_TYPE=-ibm 1
${CPT_MODEL_PFX}.%: CPT_PRUNE1=-prune1w 100

${CPT_MODEL_PFX}%${L1_2_L2X}: SHELL=${FRAMEWORK_SHELL}
${CPT_MODEL_PFX}%${L1_2_L2X}:
	RP_PSUB_OPTS="-${CPT_CPUS} -N $@ ${PSUB_OPTS}" \
	${TIME_MEM} \
	joint2cond_phrase_tables \
		${CPT_PRUNE1} \
		-v -i -z \
		${WORD_MODEL_TYPE} \
		-1 ${lang1} -2 ${lang2} \
		${CPT_SMOOTHERS} \
		-multipr fwd \
		-o $(subst .${L1_2_L2X},,$@) \
		-ibm_l2_given_l1  $(filter %${L2_GIVEN_L1X}, $+) \
		-ibm_l1_given_l2  $(filter %${L1_GIVEN_L2X}, $+) \
		${JOINT2COND_PHRASE_TABLE_OPTION} \
		$(filter %${JOINTX}, $+) \
		&> log.${@:.gz=}

# Special case to make valid prune1w reversed conditional phrase tables.
# Requires:
# - forward & backward phrase alignment models;
# - reversed joint frequency files.
${CPT_MODEL_PFX}%${L2_2_L1X}: SHELL=${FRAMEWORK_SHELL}
${CPT_MODEL_PFX}%${L2_2_L1X}:
	RP_PSUB_OPTS="-${CPT_CPUS} -N $@ ${PSUB_OPTS}" \
	${TIME_MEM} \
	joint2cond_phrase_tables \
		${CPT_PRUNE1} \
		-v -i -z \
		${WORD_MODEL_TYPE} \
		-1 ${lang2} -2 ${lang1} \
		${CPT_SMOOTHERS} \
		-multipr fwd \
		-o $(subst .${L2_2_L1X},,$@) \
		-ibm_l2_given_l1  $(filter %${L1_GIVEN_L2X}, $+) \
		-ibm_l1_given_l2  $(filter %${L2_GIVEN_L1X}, $+) \
		${JOINT2COND_PHRASE_TABLE_OPTION} \
		$(filter %.${RJOINTX}, $+) \
		&> log.${@:.gz=}



########################################
# GIZA SPECIFIC TARGETS.
$(addsuffix /,${TRAIN_TM}):  %:
	mkdir -p $@


# Clean up the inputs for giza.
%/${SRC_LANG}.lc:  %_${SRC_LANG}.lc.gz %_${TGT_LANG}.lc.gz  | %/
	giza_filter $+ $@ ${@:${SRC_LANG}.lc=${TGT_LANG}.lc} 2> log.giza_filter

%/${TGT_LANG}.lc:  %/${SRC_LANG}.lc
	@true


# Create the vocabulary files.
.PHONY:  vcb
vcb:  $(addsuffix /${SRC_LANG}.lc.vcb, ${TRAIN_TM})
vcb:  $(addsuffix /${TGT_LANG}.lc.vcb, ${TRAIN_TM})
%/${SRC_LANG}.lc.vcb:  %/${SRC_LANG}.lc  %/${TGT_LANG}.lc | %/
	plain2snt $+

%/${TGT_LANG}.lc.vcb:  %/${SRC_LANG}.lc.vcb 
	@true

%/${SRC_LANG}.lc_${TGT_LANG}.lc.snt:  %/${SRC_LANG}.lc.vcb %/${TGT_LANG}.lc.vcb
	@true


# Create the vocabulary classes.
.PHONY: classes
classes:  $(addsuffix /${SRC_LANG}.lc.vcb.classes, ${TRAIN_TM})
classes:  $(addsuffix /${TGT_LANG}.lc.vcb.classes, ${TRAIN_TM})
%.lc.vcb.classes:  %.lc
	mkcls -m2 -p$< -c50 -V$@ opt &> $@.log


# Create the cooccurrence counts.
.PHONY: cooc
cooc:  $(addsuffix /${L1_2_L2}.cooc, ${TRAIN_TM})
cooc:  $(addsuffix /${L2_2_L1}.cooc, ${TRAIN_TM})
%/${L1_2_L2}.cooc:  %/${SRC_LANG}.lc.vcb %/${TGT_LANG}.lc.vcb | %/
	snt2cooc $@  $+ $*/$(call merge,_,$(notdir $(basename ,$+))).snt

%/${L2_2_L1}.cooc:  %/${TGT_LANG}.lc.vcb %/${SRC_LANG}.lc.vcb | %/
	snt2cooc $@  $+ $*/$(call merge,_,$(notdir $(basename ,$+))).snt


# Perform word alignment.
.PHONY: cfg
cfg:  $(addsuffix /B.gizacfg, ${TRAIN_TM})
cfg:  $(addsuffix /F.gizacfg, ${TRAIN_TM})
%/B.gizacfg:  %/${SRC_LANG}.lc.vcb %/${TGT_LANG}.lc.vcb  %/${SRC_LANG}.lc.vcb.classes %/${TGT_LANG}.lc.vcb.classes  %/${L1_2_L2}.cooc
	mgiza \
		-ncpus 4 \
		-S $(filter %${SRC_LANG}.lc.vcb,$+) \
		-T $(filter %${TGT_LANG}.lc.vcb,$+) \
		-C $*/$(call merge,_,$(notdir $(basename $(filter %.vcb,$+)))).snt \
		-p0 0.98 \
		-coocurrencefile $(filter %.cooc,$+) \
		-outputpath $* \
		-ml 101 \
		-o B \
		&> $@.log

%/F.gizacfg:  %/${TGT_LANG}.lc.vcb %/${SRC_LANG}.lc.vcb  %/${TGT_LANG}.lc.vcb.classes %/${SRC_LANG}.lc.vcb.classes  %/${L2_2_L1}.cooc
	mgiza \
		-ncpus 4 \
		-S $(filter %${TGT_LANG}.lc.vcb,$+) \
		-T $(filter %${SRC_LANG}.lc.vcb,$+) \
		-C $*/$(call merge,_,$(notdir $(basename $(filter %.vcb,$+)))).snt \
		-p0 0.98 \
		-coocurrencefile $(filter %.cooc,$+) \
		-outputpath $* \
		-ml 101 \
		-o F \
		&> $@.log


#	| perl -ne '$$id=$$_; chomp $$id; $$id=~s/# Sentence pair \(//; $$t=<>; chomp $$t; $$s=<>; chomp $$s; print "$$id$$t$$s\n"' \
#	| sort -n \
#	| sed -e 's/^/# Sentence pair (/; s//\n/g'
.PHONY:  giza_al
giza_al:  $(addsuffix /${L1_2_L2}.${GIZA_MODEL_PFX}.alignment.gz, ${TRAIN_TM})
giza_al:  $(addsuffix /${L2_2_L1}.${GIZA_MODEL_PFX}.alignment.gz, ${TRAIN_TM})
$(addsuffix /${L1_2_L2}.${GIZA_MODEL_PFX}.alignment.gz, ${TRAIN_TM}):  %/${L1_2_L2}.${GIZA_MODEL_PFX}.alignment.gz:  %/B.gizacfg
$(addsuffix /${L2_2_L1}.${GIZA_MODEL_PFX}.alignment.gz, ${TRAIN_TM}):  %/${L2_2_L1}.${GIZA_MODEL_PFX}.alignment.gz:  %/F.gizacfg
%.${GIZA_MODEL_PFX}.alignment.gz:
	set -o pipefail; \
	merge_alignment.py ${<:gizacfg=A3.final.part}* \
	| gzip > $@


# Converts GIZA ttables in a format that portage understands.
${GIZA_MODEL_PFX}.%.${L1_GIVEN_L2X}:  %/${SRC_LANG}.lc.vcb %/${TGT_LANG}.lc.vcb  %/B.gizacfg
	set -o pipefail; \
	giza_convert_ttable $(filter %.lc.vcb,$+) $(patsubst %.gizacfg,%.t3.final,$(filter %.gizacfg,$+)) \
	| gzip > tmp.$@
	train_ibm -tobin tmp.$@ $@
	rm -f tmp.$@

${GIZA_MODEL_PFX}.%.${L2_GIVEN_L1X}:  %/${TGT_LANG}.lc.vcb %/${SRC_LANG}.lc.vcb  %/F.gizacfg
	set -o pipefail; \
	giza_convert_ttable $(filter %.lc.vcb,$+) $(patsubst %.gizacfg,%.t3.final,$(filter %.gizacfg,$+)) \
	| gzip > tmp.$@
	train_ibm -tobin tmp.$@ $@
	rm -f tmp.$@




########################################
# Create tightly packed conditional phrase table.
%.tppt: SHELL=${FRAMEWORK_SHELL}
%.tppt: %.gz
	RP_PSUB_OPTS="-${TPPT_CPUS} -N $@" \
	${TIME_MEM} \
	textpt2tppt.sh -v $< \
	2> log.$@


########################################
# Transform models for PortageLive
# Note: portageLive dependencies are defined in Makefile (or Makefile.zn-adapt)
PORTAGE_LIVE_DEST_DIR ?= ../portageLive/models/tm
.PHONY: portageLive
portageLive: SHELL=${GUARD_SHELL}
portageLive:
	mkdir -p ${PORTAGE_LIVE_DEST_DIR}
	${RM} -r ${PORTAGE_LIVE_DEST_DIR}/*
	cd ${PORTAGE_LIVE_DEST_DIR} && ln -fs $(addprefix ../../../tm/, $+) .


################################################################################
# HELPERS

########################################
# INVERT ANY JOINT PHRASE TABLE
# WARNING: Using tmtext_sort.sh produces a valid jpt for joint2cond but
# produces an INVALID jpt for merge_counts.  Prefer the version using LC_ALL=C
# sort rather than tmtext_sort.
%.${RJOINTX}: SHELL=${FRAMEWORK_SHELL}
%.${RJOINTX}: %.${JOINTX}
	@_LOCAL=1; echo "Generating $@" >&2
	RP_PSUB_OPTS="-1 -N $@" \
	set -o pipefail; \
	zcat $< \
	| reverse_joint_phr_tab.py \
	| TMPDIR=. LC_ALL=C sort \
	| gzip \
	> $@




################################################################################
# UNITTESTS.
