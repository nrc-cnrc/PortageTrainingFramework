# vim:noet:ts=3:nowrap
# $Id$
# @author Samuel Larkin
# @brief Master parameter file where all user specific parameters should be set.
#
# Technologies langagieres interactives / Interactive Language Technologies
# Inst. de technologie de l'information / Institute for Information Technology
# Conseil national de recherches Canada / National Research Council Canada
# Copyright 2008, Sa Majeste la Reine du Chef du Canada
# Copyright 2008, Her Majesty in Right of Canada

################################################################################
# User definable variables

# This is the from/source language
export SRC_LANG ?= en
# This is the to/target language
export TGT_LANG ?= fr

# Here we specify the stem of the corpora files.
# files should look like this: <PREFIX>_<LANGUAGE>.al
# Warning: only TEST_SET can contain more than one <PREFIX>
# i.e. test1_fr.al
# TRAIN_LM is used to create a language model.
export TRAIN_LM      ?= lm-train
# TRAIN_TM is used to create the translation table.
export TRAIN_TM      ?= tm-train
# TUNE_DECODE is used to train cow.
export TUNE_DECODE   ?= dev1
# TUNE_RESCORE is used to train rat.
export TUNE_RESCORE  ?= dev2
# TUNE_CE is used to train confidence estimation.
#export TUNE_CE       ?= dev3
# TEST_SET are used to estimate the quality of the system.
export TEST_SET      ?= test1 test2
# Uncomment if you have source text, that doesn't have a reference, to translate.
#TRANSLATE_SET ?=

# The prefix_root where we can find IRSTLM/bin, which must also be on your
# PATH.  (Only need if you are using IRSTLM - see next variable.)
export IRSTLM ?= $(PORTAGE)/pkgs/irstlm

# Change LM_TOOLKIT's value depending on the available lm tooolkit that you
# have.  If you use SRILM or MITLM, their executable scripts and programs
# should be on your PATH.
# LM_TOOLKIT={SRI,IRST,MIT} 
# where SRI  => SRILM's toolkit
#       IRST => IRSTLM's toolkit
#       MIT  => MITLM's toolkit
LM_TOOLKIT = SRI

# Train and apply rescoring if this variable is defined.
# Comment out to disable rescoring.
DO_RESCORING = 1

# Tune and apply confidence estimation if this variable is defined.
# Comment out to enable confidence estimation.
#DO_CE = 1

# Train and apply truecassing if this variable is defined.
# Comment out to disable truecasing.
DO_TRUECASING = 1

# If you have ICU installed and have compiled PORTAGE shared with icu,
# uncomment the following line.
#ICU = 1

# If you are on a cluster that is run-parallel.sh friendly, define the
# following to force cluster mode.  You normally don't need to do so, though,
# since clusters are detected automatically below.
#USING_CLUSTER = 1

# If you are on a cluster but you want to force single computer mode,
# uncomment the following line:
#export NOCLUSTER = 1

# Automatically detects if we are on a cluster.
ifeq ($(strip $(shell which-test.sh qsub && echo "true")),true)
   USING_CLUSTER ?= 1
endif
ifdef NOCLUSTER
   USING_CLUSTER =
endif
export USING_CLUSTER


ifdef USING_CLUSTER
PARALLELISM_LEVEL_CORPORA ?= 10
PARALLELISM_LEVEL_LM ?= 5
PARALLELISM_LEVEL_TM ?= 5
PARALLELISM_LEVEL_TUNE_DECODE  ?= 10
PARALLELISM_LEVEL_TUNE_RESCORE ?= 10
PARALLELISM_LEVEL_TRANSLATE    ?= 10
$(warn "Running in cluster mode.")
else
# Make sure we run in serial mode.
.NOTPARALLEL:
# Autodetect the number of available cpus on this machine.
NCPUS := $(shell grep processor /proc/cpuinfo | \wc -l)
PARALLELISM_LEVEL_CORPORA ?= ${NCPUS}
PARALLELISM_LEVEL_LM ?= ${NCPUS}
PARALLELISM_LEVEL_TM ?= ${NCPUS}
PARALLELISM_LEVEL_TUNE_DECODE  ?= ${NCPUS}
PARALLELISM_LEVEL_TUNE_RESCORE ?= ${NCPUS}
PARALLELISM_LEVEL_TRANSLATE    ?= ${NCPUS}
$(warn "Running in local mode.")
endif
export PARALLELISM_LEVEL_CORPORA
export PARALLELISM_LEVEL_LM
export PARALLELISM_LEVEL_TM
export PARALLELISM_LEVEL_TUNE_DECODE
export PARALLELISM_LEVEL_TUNE_RESCORE
export PARALLELISM_LEVEL_TRANSLATE


################################################################################
# Advanced configuration variables

# Compress extension.
export GZ ?= .gz

# Raw file's extension.
export ALIGNX ?= .al

# Extension for rule files which must also be source file.
export RULEX ?= _${SRC_LANG}.rule

# Language extension for phrase table corpora.
# Extension for corpora.
export LANGX  ?= .lc
# Extension for compressed corpora.
export LANGXZ ?= ${LANGX}${GZ}

# Language pair for this system.
export LANGS ?= ${SRC_LANG} ${TGT_LANG}

# Define the corpora.
export TRAIN_SET    ?= ${TRAIN_LM} ${TRAIN_TM}
export HELDOUT_SET  ?= ${TUNE_DECODE} ${TUNE_RESCORE} ${TUNE_CE} ${TEST_SET}
export CORPORA_SET  ?= ${TRAIN_SET} ${HELDOUT_SET}

# Define what type of phrase table we want to generate.
# Can be: {ibm2_cpt | hmm1_cpt | hmm2_cpt}
export PT_TYPES ?= ibm2_cpt hmm3_cpt

# Define what type of language model we want to generate.
export LM_TYPES ?= binlm

# Parameters for models/decode/Makefile
#export TEMPLATE_DIR    ?= ${ROOT_DIR}/models/decode
export PREFIX_DEV_COW  ?= ${TUNE_DECODE}
export PREFIX_DEV_RAT  ?= ${TUNE_RESCORE}

# Defines the truecasing model filename.
export TRUECASING_MAP ?= ${TRAIN_LM}_${TGT_LANG}.map
export TRUECASING_LM  ?= ${TRAIN_LM}_${TGT_LANG}-kn-3g.binlm${GZ}

# Define the following variable if you want to create forward and backward phrase tables
#export BIDIRECTIONAL_SYSTEM = 1




# If we are lucky enough to have a cluster, we'll change the shell for certain
# commands and allow them to run on nodes.
ifdef USING_CLUSTER
FRAMEWORK_SHELL = run-parallel.sh
else
FRAMEWORK_SHELL = /bin/bash
endif

# Some commands shouldn't be run with the cluster shell, will use this one
# instead.
GUARD_SHELL = /bin/bash

########################################
# VALIDATING.
ifdef DO_CE
ifeq (${TUNE_CE},)
$(error "When asking for confidence estimation, you must also define a TUNE_CE!")
endif
endif

ifdef DO_RESCORING
ifeq (${TUNE_RESCORE},)
$(error "When asking for rescoring, you must also define a TUNE_RESCORE!")
endif
endif

ifeq (${TRAIN_LM},)
$(error "You must always define a training corpus for language model.")
endif

ifeq (${TRAIN_TM},)
$(error "You must always define a training corpus for translation model.")
endif

ifeq (${TUNE_DECODE},)
$(error "You must always define a tuning corpus train the decoder.")
endif

ifeq (${SRC_LANG},)
$(error "You must provide a SRC_LANG!")
endif

ifeq (${TGT_LANG},)
$(error "You must provide a TGT_LANG!")
endif

ifeq (${SRC_LANG},${TGT_LANG})
$(error "SRC_LANG=${SRC_LANG} cannot be the same as TGT_LANG=${TGT_LANG}!")
endif
